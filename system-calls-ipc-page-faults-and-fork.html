<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="demo2s : DemoOS: MIT OCW 6.828" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>demo2s: system-calls ipc page-faults fork</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/linxiaohui/demo2s">View on GitHub</a>

          <h1 id="project_title">demo2s</h1>
          <h2 id="project_tagline">DemoOS: MIT OCW 6.828</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/linxiaohui/demo2s/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/linxiaohui/demo2s/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a name="system-calls-and-ipc" class="anchor" href="#system-calls-and-ipc"><span class="octicon octicon-link"></span></a>System calls and IPC</h2>

<h3>
<a name="about-env" class="anchor" href="#about-env"><span class="octicon octicon-link"></span></a>About Env</h3>

<p>用户进程在<code>user/</code>下的文件定义. 由<code>user/Makefrag</code>文件可知用户进程的运行原理:<br>
1. 源文件(如<code>hello.c</code>)编译成目标文件(<code>hello.o</code>)<br>
2. 将其与<code>entry.S</code>汇编成的目标文件<code>entry.o</code>以及一些用户进程中通用的函数(<code>fork.o,ipc.o,libos.o,pgfault.o,printf.o,string.o,syscall.o</code>)等ld为"可执行文件"(<code>hello.b</code>)<br>
3. <code>bintoc</code>将该可执行文件转变成c源文件(<code>hello.b.c</code>): 将二进制形式转化成 char , 并且定义符号(<code>binary_user_hello_start</code>,<code>binary_user_hello_size</code>, <code>在ENV_CREATE</code>宏中用)<br>
4. 编译成可以被ld使用的文件(hello, 内有符号<code>binary_user_hello_start</code>, <code>binary_user_hello_size</code>)<br>
5. 用户程序被ld到内核中, ld会根据内核的<code>ENV_CREATE</code>查找符号(如<code>binary_user_hello_start</code>等).</p>

<p>由上面所述的过程可知, 当一个用户进程被运行时, 它首先执行<code>user/entry.S</code>中的代码为程序做一些初始设置.
然后调用<code>user/libos.c</code>中的<code>libmain()</code>, 该函数调用相应的用户程序的<code>umain()</code>.</p>

<p>注意: 每个程序都有自己独立的<code>entry.S</code>. 同样, 每个程序也都有自己的<code>libos.c</code>中的内容<br>
因此，每个进程都有一个变量<code>env</code>指向自己的进程控制块(<code>user/libos.c</code>), 并且每个进程都有一个整型变量<code>__pgfault_handler</code>  </p>

<h3>
<a name="system-calls" class="anchor" href="#system-calls"><span class="octicon octicon-link"></span></a>System calls</h3>

<p>编写内核系统调用的dispatch函数及实现系统调用的函数并编写用户级的系统调用的接口</p>

<p>理解系统调用的过程:<br>
1. 在用户的程序中, 调用系统调用接口(例如<code>sys_getenvid</code>), 实际上是调用了<code>user/syscall.c</code>中相应的函数(根据Makefile)<br>
2. 相应的函数调用<code>user/syscall.c</code>中的<code>syscall()</code>, 该函数是用户通向内核的接口<br>
3. <code>syscall()</code>将参数放到相应的寄存器(<code>system call number</code>: %eax; arguments: %edx, %ecx, %ebx, %edi, and %esi)<br>
4. 执行int 0x30指令,产生一个中断.<br>
5. 系统根据已经设置好的idt(<code>kern/trap.c</code>), 找到idt[0x30], 执行相应的中断处理函数(<code>kern/locore.S</code>)<br>
6. 中断处理函数填好参数后, 调用<code>kern/trap.c</code>中<code>trap()</code>  (trap()根据中断向量号调用相应的处理函数)<br>
7. <code>trap()</code>使用中断的<code>Trapframe</code>中的<code>ebx等</code>做为参数, 调用<code>kern/syscall.c</code>中的<code>syscall()</code><br>
8. <code>syscall()</code>根据系统调用号分派不同处理函数<code>kern/syscall.c</code>中<code>sys_*()</code>, 将该函数的返回值存放在中断的<code>Trapframe</code>的<code>eax</code>  </p>

<p>这样, 中断返回时, 从Trapframe中恢复寄存器的值, eax寄存器里就保存系统调用的返回值.</p>

<p>Note:
    interrupt 0x30 cannot be generated by hardware, </p>

<h3>
<a name="interprocess-communication-ipc" class="anchor" href="#interprocess-communication-ipc"><span class="octicon octicon-link"></span></a>Interprocess communication (IPC)</h3>

<p>如果一个进程要接收消息, 调用系统调用<code>sys_ipc_recv</code> 将其标记为正在接受消息(在进程控制块的相应的域中标记), 
然后将其标记成处于不可运行的状态.</p>

<p>如果一个进程要向某个进程发送消息, 调用系统调用<code>sys_ipc_can_send</code>测试一进程是否处于接收消息的状态, 如果是则将相应的消息传给它(在其进程控制块中标记,然后将其变成可运行的状态).
否则,返回值告诉调用者相应的进程不是处于接收消息的状态.</p>

<h2>
<a name="page-fault-handling-from-kernel-and-user-modes" class="anchor" href="#page-fault-handling-from-kernel-and-user-modes"><span class="octicon octicon-link"></span></a>Page fault handling from kernel and user modes</h2>

<p>用户态产生page fault的处理过程:</p>

<p>每个进程都有自己的页故障处理函数. 发生页故障时, 系统会进入中断处理的过程:<br>
1. 硬件系统会将产生故障的线性地址存放在<code>cr2</code>寄存器中, 并将寄存器<code>ss</code>, <code>esp</code>,<code>eflags</code>, <code>cs</code>,<code>eip</code>压入系统栈中<br>
2. 同时压入栈中的还有系统产生一个错误码(Error Code), 标志故障的类型[1].<br>
3. 在中断描述符表(idt)中找到相应的中断描述符(idt[0xe]), 执行相应的处理函数(<code>kern/locaore.S</code>)<br>
4. 该函数设置好Trapframe后, 调用<code>kern/trap.c</code>中的<code>trap()</code>处理函数<br>
5. <code>trap()</code>在页故障时调用<code>kern/trap.c</code>中的<code>page_fault_handler()</code><br>
6. <code>page_fault_handler()</code>设置用户进程的异常栈并调用用户的页故障处理函数. 
用户进程的异常栈和页故障处理函数在进程控制块中描述, 用户通过调用<code>set_pgfault_handler()</code>(<code>user/pgfault.c</code>)对其进行设置.
<code>set_pgfault_handler()</code>调用系统调用<code>sys_set_pgfault_handler()</code>.
所有用户进程的页故障处理函数的均为<code>entry.S</code>中定义的<code>__asm_pgfault_handler</code>.调用值为<code>__pgfault_handler</code>的地址处的代码</p>

<p>注: <code>__pgfault_handler</code>是用户进程中的一个变量. 
<code>set_pgfault_handler()</code>为进程申请异常栈空间,并调用系统调用<code>sys_set_pgfault_handler()</code>将<code>__asm_pgfault_handler</code>. 
赋予进程控制块中相应的域(env_pgfault_handler)并将其参数(一个函数)赋值给变量<code>__pgfault_handler</code>.</p>

<p>[1]关于页故障时的错误代码的资料</p>

<pre><code>在地址转换过程中，如果出现下列情况之一就会引起页异常（页故障）： 
(1)涉及的页目录表内的表项或页表内的表项中的P=0，即涉及到页不在内存； 
(2)发现试图违反页保护属性的规定而对页进行访问。 

报告页异常的中断向量号是14(0EH)。 

页异常属于故障类异常。 

在进入故障处理程序时，保存的指令指针CS及EIP指向发生故障的指令。 
当页故障发生时，处理器把引起页故障的线性地址装入CR2。 
页故障还在堆栈中提供一个出错码，出错码的格式如下所示。 

15—-3 2 1 0 
 0……0 U W P 

U位表示引起故障程序的特权级. 
U=1表示用户特权级(特权级3)，U=0表示系统特权级(特权级0、1或2) 
W位表示访问类型 
W=0表示读/执行，W=1表示写. 
P位表示异常类型 
P=0表示页不存在故障，P=1表示保护故障。 
</code></pre>

<p>发生页故障时系统可能处于用户态,也可能处于内核态.
内核自身是不能发生页故障的, 所以若内核自身发生页故障, 系统应该<code>panic</code>; </p>

<p>但是发生在内核态的页故障不一定是内核自身发生页故障; 
典型的情况是内核在执行用户进程的系统调用请求时发生页故障, 则说明用户进程传递的参数有问题:
比如一个不在内存中的页的地址等等; 这时是系统代表用户进程发生页故障。</p>

<p><code>page_fault_mode()</code> (<code>kern/trap.c</code>)标记这两种状态.</p>

<p>在<code>kern/trap.c</code>的<code>page_fault_handler()</code>中, 检查Trapframe的cs域(这是发生页故障时cs寄存器的值), 
末两位11为用户态,00为内核态.</p>

<p>如果是在内核态时发生页故障, 检查 <code>page_fault_mode</code> 的值, 如果为<code>PFM_NONE</code>则说明内核发生页故障, <code>panic()</code>;
如果为<code>PFM_KILL</code>说明是用户进程有问题,中止当前进程的运行.</p>

<p>另一个问题是用户进程调用系统调用时, 可能传递给内核一个自己无权访问的地址.
因此, 用户进程传递内核的每一个地址, 都须经过<code>TRUP</code>(<code>inc/mmu.h</code>), 该宏将所有大于ULIM的值转变为ULIM, 
结合虚拟内存布局可知, 在正常的情况下, 访问ULIM会产生页故障(即使是内核),因此, 用户进程不会访问其无权访问(&gt;=ULIM)的地址.
如果页故障发生在用户态, 则检查用户进程中实否设置了页故障处理函数; 如果用户进程没有页故障处理函数, 将进程杀死.
否则, <code>page_fault_handler()</code>的主要任务是设置用户进程的异常栈并调用用户的页故障处理函数.</p>

<p>用户进程的异常栈的格式如下图:</p>

<pre><code>    &lt;-- env_xstacktop
empty
empty
empty
empty
empty
tf-&gt;tf_eip
tf-&gt;tf_eflags
tf-&gt;tf_esp
tf-&gt;tf_err
fault_va    &lt;-- %esp when handler is run
</code></pre>

<p>或：</p>

<pre><code>    &lt;-- tf-&gt;esp
empty
empty
empty
empty
empty
tf-&gt;tf_eip
tf-&gt;tf_eflags
tf-&gt;tf_esp
tf-&gt;tf_err
fault_va    &lt;-- %esp when handler is run
</code></pre>

<p>第二种情况对应的是发生递归故障时(即页故障处理函数中又出现页故障)的情形</p>

<p>设置好异常栈后, 应该调用用户的页故障处理函数(<code>env_pgfault_handler</code>)<br>
注意: 用户进程的页故障处理函数是在用户态执行, 所以其执行完毕之后不会返回内核态.
(因为用户态切换到内核态只能通过中断, 而中断处理的流程是一致的, 并且一次中断会覆盖上一次中断保存的环境信息).
而中断从内核态返回用户态必须恢复发生中断时的环境(寄存器的值),并且这些寄存器的值不可能通过异常栈传递.</p>

<p>因此, 在这里还需要恢复相应寄存器的值.
一种办法是: 将异常栈的栈顶值赋给<code>Trapframe的esp域</code>, 将<code>env_pgfault_handler的值</code>赋给系统栈中的<code>Trapframe结构的eip域</code>.
然后调用<code>env_run()</code> (<code>kern/env.c</code>)来运行当前进程.<br><code>env_run()</code> 首先将系统栈中的Trapframe结构保存到当前进程的进程控制块中.<br>
这样, 进程控制块中的esp, eip就变成了异常栈顶与页故障处理函数的地址. 其它寄存器对应的域的值即为发生页故障时相应寄存器的值.<br>
然后根据当前进程的进程控制块中的寄存器对应的域的值设置寄存器. 这样, 既完成了堆栈切换与代码跳转, 又完成了环境的恢复.</p>

<p>当用户进程执行其页故障处理函数时, 首先执行<code>user/entry.S</code>中的<code>__asm_pgfault_handler</code></p>

<pre><code> 1 __asm_pgfault_handler:
 2    // save the caller-save registers
 3    movl %eax,28(%esp)
 4    movl %ecx,24(%esp)
 5    movl %edx,20(%esp)
 6
 7    // call the C page fault handler
 8    movl __pgfault_handler, %eax
 9    call *%eax
10
11    // push trap-time eip, eflags onto trap-time stack
12    movl 8(%esp),%eax  //将发生页故障时（trap-time）的esp寄存器的值赋给eax寄存器
13    movl 16(%esp),%edx //trap-time时eip寄存器的值赋给edx寄存器
14    movl %edx,-4(%eax) //保存在正常栈的下一位置
15    movl 12(%esp),%edx //trap-time时eflags寄存器的值赋给edx寄存器
16    movl %edx,-8(%eax) //保存在正常栈的下下一位置
17
18    // restore the caller-save registers
19    movl 28(%esp),%eax
20    movl 24(%esp),%ecx
21    movl 20(%esp),%edx
22
23    // switch to the trap-time stack
24    movl 8(%esp),%esp //切换至正常堆栈
25    subl $8,%esp //eflags和eip
26
27    // restore eflags and eip from the stack
28    popfl
29    ret

</code></pre>

<p>[行3-5]保存caller-saved寄存器(eax、ecx、edx),<br>
[行8-9]调用地址值为__pgfault_handler处的代码(即为用户写的处理函数)<br>
[行12-16]将发生页故障时的eip、eflags放到用户进程的(正常)栈中<br>
[行19-21]恢复caller-saved寄存器(eax、ecx、edx);<br>
[行24-25]将堆栈切换到正常堆栈.(将发生页故障时的esp寄存器的值,即tf-&gt;tf_esp赋给esp)<br>
[行28-29]恢复eflags(popf), 返回(ret).</p>

<p>在发生递归页故障(即页故障处理函数中又出现页故障)时, 异常栈的布局应该如图:</p>

<pre><code>s   &lt;-- env_xstacktop
empty
empty
empty
empty
empty
tf-&gt;tf_eip'
tf-&gt;tf_eflags'
tf-&gt;tf_esp'
tf-&gt;tf_err'
fault_va'   &lt;-- %esp when handler is first run    &lt;-- tf-&gt;esp
empty   
empty
empty
empty
empty
tf-&gt;tf_eip
tf-&gt;tf_eflags
tf-&gt;tf_esp
tf-&gt;tf_err
fault_va    &lt;-- %esp when handler is second run （recursive page fault）

</code></pre>

<p>发生递归页故障时, 在第二次调用的<code>__asm_pgfault_handler</code>里, "正常栈"即为异常栈.<br>
因此, 将发生页故障时的eip、eflags放到用户进程的正常栈中的代码[行12-16]将使用上图中标记的两个位置.</p>

<h2>
<a name="user-level-fork" class="anchor" href="#user-level-fork"><span class="octicon octicon-link"></span></a>User-level fork</h2>

<p><code>fork</code>的功能是产生一个当前运行进程的子进程, 该子进程是当前进程的拷贝.</p>

<h4>
<a name="return-of-fork" class="anchor" href="#return-of-fork"><span class="octicon octicon-link"></span></a>RETURN of <code>fork</code>
</h4>

<p><code>fork()</code>子进程中返回0,在父进程中返回子进程的id.   </p>

<p><code>fork()</code>首先调用系统调用<code>sys_env_alloc</code>产生一个新的进程; <code>sys_env_alloc</code>申请一个进程控制块作为子进程的PCB,
将当前进程的PCB控制块的内容拷贝给它.除了eax对应的域, 这个域应设置成0.(**), 然后返回新创建进程的pid.<br><code>sys_env_alloc</code>执行完成后, 发生系统调用时的Trapframe的eax域为子进程id. 
当系统调用中断返回时, 从Trapframe中恢复环境, eax寄存器值为子进程id,<code>sys_env_alloc</code>的返回值.</p>

<p>之后在父进程中实现COW的设置, 为子进程设置页故障处理函数,将子进程设置为可运行, 并返回子进程id;</p>

<p>当子进程被调度,调用<code>env_run</code>函数, 从其PCB中恢复环境, eax寄存器值为0.
返回用户态时, 父进程与子进程开始时执行相同的指令, 所以eax寄存器的值都被认为是函数的返回值.</p>

<p>(**)<br>
C中函数返回值是放在eax寄存器里的</p>

<h4>
<a name="memory" class="anchor" href="#memory"><span class="octicon octicon-link"></span></a>MEMORY</h4>

<p>fork后两个进程不共享内存, 但不是在子进程产生之时就拷贝内存.使用COW(Copy On Write)机制, 即写时拷贝.<br>
由于不采用创建时拷贝物理页面的方法, 父进程创建出子进程后, 其相同的线性地址对应相同的物理页面.<br>
读操作不会带来什么问题, 但写操作会使物理页改变, 而父进程与子进程不共享内存页面, 因此此时必须拷贝.   </p>

<p><code>fork()</code>通过系统调用<code>sys_env_alloc</code>得到一子进程后, 父进程设置物理页面的属性:<br>
在其地址空间内, 如果某一页面有写权限或COW权限, 去掉写权限, 加上COW权限.<br>
这样, 当用户进程(父进程或子进程)对某一页进行写操作时, 将发生页故障;<br>
其页故障处理函数可以检查该页是否有COW权限,如果有, 则将该页的内容拷贝到一新申请的物理页面中.<br>
然后将新页影射到原来的线性地址上. 否则即发生了错误的情况.  </p>

<h2>
<a name="summary" class="anchor" href="#summary"><span class="octicon octicon-link"></span></a>SUMMARY</h2>

<h3>
<a name="memroy-addressing" class="anchor" href="#memroy-addressing"><span class="octicon octicon-link"></span></a>MEMROY ADDRESSING</h3>

<p>在用户进程中访问页目录与页表是fork中的重点.
用户进程的vpd[]、vpt[]可以访问某页的页目录项和页表项.</p>

<p>理解这点除了要理解保护模式下的内存寻址方式外, 还要理解一个进程的虚拟内存布局以及vpd、vpt的值和意义.</p>

<p><code>vpt</code>, <code>vpd</code>在<code>user/entry.S</code>中定义, vpt值为UVPT, vpd值为(UVPT+(UVPT&gt;&gt;12)*4).<br>
在<code>kern/env.c</code>的<code>env_setup_vm()</code>, 将页目录自身影射到页目录的第PDX(UVPT)项.<br>
这样就可以用vpd访问用户进程空间某线性地址所在页的页目录项, 可以用vpt访问用户进程空间中某线性地址所在页的页表项.   </p>

<p>举例如下:
设一地址va, <code>vpd[va/4M]</code>表示va所在页的页目录项. 寻址过程如下:<br>
为了便于叙述, 不妨设用户进程的页目录所在的物理页为PageA. 前面已经说过PageA的第PDX(UVPT)项指向PageA.<br>
va所在页面的页目录项为PageA的第<code>PDX(va)</code>项. vpd[va/4M]的线性地址为<code>vpd+4*va/4M</code>,<br><code>PDX(vpd+ 4* va/4M=PDX(UVPT)</code>, 因此经过一级寻址后, 得到的页表为PageA;<br><code>PTX(vpd+4* va/4M)=PDX(UVPT)</code>, 因此经过二级寻址后，得到的页面为PageA.<br>
页内偏移即为<code>PGOFF(4*va/4M)=4*va/4M</code>, 为其第va/4M项(vpd为整型数组);<br>
注意到<code>PDX(va)=va/4M</code>, 因此<code>vpd[va/4M]</code>表示va所在页的页目录项.</p>

<p>下面说明<code>vpt[va/4K]</code>表示va所在页面的页目录项.<br>
va所在页面的页目录项为PageA的第PDX(va)项所指向的页面的第PTX(va)项, 即该页中偏移为4*PTX(va)的项.<br>
与上面所述的过程类似, <code>vpt[va/4K]</code>线性地址为<code>vpt+4*va/4K</code>.<br><code>PDX(vpt+4*va/4K)=PDX(vpt)=PDX(UVPT)</code>, 经过一级寻址后得到页表为PageA.<br><code>PTX(vpt+4*va/4K)=PTX(4*va/4K)=PDX(va)</code>, 经过二级寻址后, 得到页面为PageA的第PDX(va)项对应的页面.<br>
页内偏移为<code>PGOFF(4*va/4K)=(va&gt;&gt;10)&amp;0xfff</code>. <code>4*PTX(va)=4*(va&gt;&gt;12)&amp;0x3ff</code> 二者是相等的.<br>
这就说明vpt[va/4K]表示va所在页面的页目录项。  </p>

<h3>
<a name="cmos" class="anchor" href="#cmos"><span class="octicon octicon-link"></span></a>CMOS</h3>

<p>内核通过读<a href="CMOS.png">CMOS中的数据</a>来得到系统拥有的内存的数量(<code>kern/pmap.c</code>中读CMOS的0x17、0x18).</p>

<h2>
<a name="trouble-shooting" class="anchor" href="#trouble-shooting"><span class="octicon octicon-link"></span></a>Trouble Shooting</h2>

<h4>
<a name="build-error" class="anchor" href="#build-error"><span class="octicon octicon-link"></span></a>Build error</h4>

<p><code>error : conflicting types for ‘bcopy’</code></p>

<p>inc/mmu.h</p>

<pre><code>++ #ifndef __USE_BSD
   void bcopy(const void *, void *, size_t);
   void bzero(void *, size_t);
++ #endif
</code></pre>

<h4>
<a name="garbage-in-page" class="anchor" href="#garbage-in-page"><span class="octicon octicon-link"></span></a>Garbage in PAGE</h4>

<p><code>fork()</code>中父进程将已存在于自己的地址空间的内存页影射到子进程的地址空间时, 页表项的内容表明相应的页面存在但页面的物理页号被认为是非法的.
    <code>pgdir_walk()</code>中对申请的页表没有清零, 导致原来在相应的页面的内容造成错误影响.</p>

<h4>
<a name="aout" class="anchor" href="#aout"><span class="octicon octicon-link"></span></a>a.out</h4>

<p>注意gcc和ld的版本/参数, 其输入/输出的文件的格式(a.out)</p>
<p><a href="index.html">Return</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">demo2s maintained by <a href="https://github.com/linxiaohui">linxiaohui</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
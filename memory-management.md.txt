
# Bochs

`vb`, `lb`, and `pb` breakpoint commands to break at virtual, linear, and physical breakpoints. 

The default `b` command breaks at a physical address.

`x` command examines data at a linear address. The command `xp` takes a physical address



# VM layout

完成实现虚拟地址到物理地址的转化的准备工作
### inc/mmu.h
理解其中定义的与地址相关的宏
### 实现二级页表的映射机制
实现下面函数

`alloc()` 在物理内存中申请一段空间并返回其在内核空间中的地址(虚拟地址)

`boot_pgdir_walk()` 返回一虚拟地址对应在页表中的页表项。

`boot_map_segment()` 设定虚拟地址到物理地址的对应关系

`i386_vm_init()`  Handle the layout of the kernel portion of the virtual address space.

实验成功与否由`check_boot_pgdir()`函数来检验

### Q&A
##### 1). Entries in the page directory
What entries in the page directory have been filled in at this point? 
What addresses do they map and where do they point?

在代码中添加检测代码可以查看pgdir[0]-pgdir[1023]的相关信息. 通过实验数据如下:
```
pgdir[0]-->0x0
pgdir[954]-->0x0
pgdir[955]--> 0x184000
pgdir[956]--> 0x166000
pgdir[957]--> 0x10c000
pgdir[958]--> 0x10d000
pgdir[959]--> 0x10c000
pgdir[960]--> 0x10e000
……
pgdir[1023]--> 0x14d000
```
它们每一个代表4M内存。

##### 2). ADDRESSING
In `i386_vm_init()`, after check_boot_page_directory (`check_boot_pgdir()`), 
we map the first entry of the page directory to the page table of the first 4 MB of RAM,
but delete this mapping at the end of the function. Why is this necessary? 
What would happen if it were omitted? 
Does this actually limit our kernel to be 4MB? 
What must be true if our kernel were larger than 4MB?

`i386_vm_init()`中`pgdir[0] = pgdir[PDX(KERNBASE)]`将 first 4 MB of RAM映射到the first entry of the page directory
(因为在前面已经将物理地址[0,2^32-1-KERNBASE]映射到虚拟地址[KERNBASE,2^32-1]). 目的是在打开页式寻址模式(lcr0)后重新装载段寄存器前还能继续正确寻址.

`pgdir[0]=0;` delete this mappping 是为了在重新装载段寄存器后能正确寻址.

原因:
在打开页式寻址模式(lcr0)后重新装载段寄存器前, 代码段和数据段的基址是`-KERNBASE` (`kern/locore.S`)
此时一地址(比如eip寄存器里的值)经过段式寻址后, 其值变成实际的物理地址(实际上在此之前都是这样的),
以此为线性地址再经过页式寻址,找到其在页目录中的entity(此时为pgdir[0]),然后找到其页表,再找到页面.
由上述过程可知这样后得到的仍为正确的物理地址(因为在前面已经将虚拟地址[KERNBASE,2^32-1]映射到物理地址 [0,2^32-1-KERNBASE])

再删除是因为重新装载段寄存器后,代码段等段的基址为0,一地址经过段式寻址后得到得是线性地址(值为内核空间地址的值),经线性寻址后成为物理地址. 
如果不正样做, 程序在执行完语句lcr0(cr0)将不能正常执行,因为CPU已经不能正确的寻址,不能将eip指向的内存中的指令取出. 

如果不重新设置pgdir[0]不会造成寻址错误, 但会造成映射错误----不在内存中的地址被认为在内存中.
这样做不会将内核限制在4M范围内,因为在重新装载段寄存器后将能正确的寻址,不会再经过pgdir[0],因而不会将内核限制在4M.当然重新装载段寄存器的代码必须在4M范围内.

##### 3). MEMORY PROTECTION
On the x86, we place the kernel and user process in the same address space.
What specific mechanism (i.e., what register, memory address, or bit thereof) is used to protect the kernel's memory against a malicious user process?

系统通过特权级实现内核与应用程序之间的保护. 

在段式内存管理下主要有:

DPL(Discriptor Privilege Leval)段描述符所代表的内存段的特权级

RPL(Requested Privilege Level) 段选择子的特权级

CPL(Current Privilege Level)当前所执行的代码的特权级(内核态/用户态)

RPL、DPL用于段访问时的特权级检查，若RPL<=DPL才允许访问
当一任务试图访问一个内存段时, 只有CPL<=DPL才允许访问

页式内存管理模式下:
内存的保护主要有页表项的R/W位U/S位及控制寄存器CR0的MP位

## Physical page management
完成用于管理物理内存的内存数据结构的布局和物理内存的删除、分配等操作.
###  inc/pmap.h
表示物理内存页的数据结构
###  inc/queue.h
链表的实现和使用
###  页面有关函数
`page_init()`   初始化代表每一内存页的数据结构(Page数组pages),将空闲的页的Page插入空闲页链表

`page_alloc()`  返回一空闲页的Page

`page_free()`   将某页的Page插入空闲页链表

`page_walk()`   得到一线性地址的pte

`page_insert()` 将某页面对应到一线性地址中

`page_remove()` 去掉线性地址对应的页面

### Q&A
##### 1) Physical memory amount
What is the maximum amount of physical memory that this operating system can support? Why?

目前该操作系统支持的最大内存数为2^32-KERNBASE字节.

因为在函数`i386_vm_init()`中,将线性空间[KERNBASE,2^32-1]映射到物理地址[0,2^32-KERNBASE-1]

##### 2) Overhead
How much space overhead is there for managing memory, if we actually had the maximum amount of 

在该实验中, 如果真的拥有256M内存,将有65×4K(内核的页目录和页表) + 64K×sizeof(Page)的空间用来管理物理内存.
    
当内存超过256M时,超过的部分在pages数组中仍有体现,它们还会在page_free_list中,还有可能被申请到,但是它们不能被寻址.

## Printf Potpourri
理解内核应如何处理IO, printf函数的实现, gcc调用规范和变参数函数的实现

### Q&A
#### 1). `printf.c` and `console.c`
Explain the interface between printf.c and console.c. 
Specifically, what function does console.c export? How is this function used by printf.c?

在printf.c中用到了console.c中定义的函数`cons_putc()`, 该函数的功能是向屏幕缓冲区中写入一字符.并将屏幕缓冲区打印到控制台上.

#### 2). `console.c`
Explain the following from `console.c`
```
if (crt_pos >= CRT_SIZE) {
	 int i;
	 bcopy (crt_buf + CRT_COLS, crt_buf, CRT_SIZE << 1);
	 for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
		 crt_buf[i] = 0x0700 | '  ';
 	crt_pos -= CRT_COLS;
}
```
这段代码是在需要时滚屏(一行)

#### 3). `warn()`

#####  Trace the execution of the following code step-by-step:
```
int x = 1, y = 3, z = 4;
warn("x %d, y %x, z %d\n", x, y, z);
```
###### a) in the call to kprintf(), to what does `fmt` point? to what does `ap` point?
`fmt`指向字符串"x %d, y %x, z %d\n"(其值为该字符串的地址)，`ap`指向`x`的值在栈中的地址
###### b) list (in-order of execution) each call to `cons_putc`, `va_arg`, and `ksprintn` 
For `cons_putc`, list its argument as well. 
For `va_arg`, list what `ap` points to before and after the call. 
For `ksprintn` list the values of it's first two arguments.

通过跟踪观察

va_arg: ap之前为x的值在栈中的地址,之后为y的值在栈中的地址

ksprintn: 1 10

cons_putc '1'

va_arg: ap之前为y的值在栈中的地址,之后为z的值在栈中的地址

ksprintn: 3 16

cons_putc '3'

va_arg: ap之前为z的值在栈中的地址,之后为z的值在栈中的地址+4

ksprintn:4 10

cons_putc '4'


##### Run the following code.
```
u_int i = 0x00646c72;
warn("H%x Wo%s", 57616, &i);
```
###### a)What is the output? Explain how this output is arrived out
输出为`He110 World`. 因为57616=0xe110，0x72=r 0x6c=l ,0x64=d. 
由于Intel X86体系结构是little-endian, 所以i变量在内存中的存储(从低到高)是0x72 0x6c 0x64 0x00
`warn()`从格式字符串中得到格式信息`%x`, 将57616从栈中取出,以16进制方式输出`e110`. 
根据格式信息`%s`, 从栈中取出i的地址(该值作为参数传递给warn), 以输出字符串的方式(一次一字节直至遇到0x00)输出成`rld`

###### b)If the x86 were instead big-endian what would you set i to in order to yield the same output? 
Would you need to change 57616 to a different value?
如果x86是big-endian并且其栈还是向下生长的, i的值应该设成0x726c6400. 不应该改变57616


##### In the following code, what is going to be printed after 'y='? Why does this happen?
```
warn("x=%d y=%d", 3);
```
y= 后面显示的是栈中的,在参数3的上方(高地址)的4字节的值(该值每次运行是确定的,但是没有意义)
因为根据gcc调用规范传递参数, 将参数压入栈中是调用者的责任: 被调用的warn函数, 根据其控制字符串到栈中取参数, 它不管参数是否传递正确.
所以它会将参数3后的数值取出, 而该数不是调用者传递的参数.

为了说明这点，可以在warn语句之前加入内联汇编,压入一个参数(比如1), 这时y=后将显示该参数.

将参数压如栈需要理解gcc调用规范和gcc中对参数传递的处理. 例如使用
`asm volatile("movl $1,%eax\n\tmovl %eax %ss:0x8(%esp)");`
一种解释是在gcc中子程序参数的传递不是通过push, 而是直接利用寄存器%esp的值对内存进行赋值, 偏移的数量由参数的位置决定


#### 4) Calling convention
Let's say that GCC changed its calling convention so that it passed arguments in declaration order (i.e., the opposite of reverse order). 
How would you have to change printf or its interface so that it would still be possible to pass it a variable number of arguments?

如果gcc改变了其调用规范, 参数传递自左向右入栈, 那么为实现可变参数的函数一个比较简单的想法是改变`inc/stdarg.h`中的`va_start`, `va_arg`宏
可将其改成
```
#define va_start(ap, last) \
      ((ap) = (va_list)&(last) - __va_size(last))
#define va_arg(ap, type) \
      (*(type *)((ap) -= __va_size(type), (ap) + __va_size(type)))
```
这样取参数时就会向栈顶方向取。



## Trouble Shooting

#### inline asm 
`kern/pmap.c:258: error: memory input 0 is not directly addressable`

gcc -v后显示版本号为4.X.x. gcc-3.3编译没有问题. 猜测是gcc的高版本改变了语法(不允许对内存进行立即数赋值)

再看出错语句`asm volatile ("lldt %0"::"m"(0))`, 其功能是将值0放到ldt中

改成这样的也能达到相同的功能`asm volatile ("lldt %%ax"::"a"(0))` 编译通过

#### section '.debug_aranges'

make时 `can not represent section '.debug_aranges' in a.out object file format`

修改kernel.lds
```
  /DISCARD/ : {
        *(.comment)
        *(.debug_*)
        }
```
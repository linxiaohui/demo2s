
### Bochs

`vb`, `lb`, and `pb` breakpoint commands to break at virtual, linear, and physical breakpoints. 
The default `b` command breaks at a physical address
`x` command examines data at a linear address. The command `xp` takes a physical address



### VM layout (of the kernel part of the VA space)
The layout of the kernel portion of the virtual address space will be handled by the `i386_vm_init()` function

这一部分的主要任务是完成实现虚拟地址到物理地址的转化的准备工作。具体说来是完成下面的任务：
1）阅读mmu.h,理解其中定义的与地址行关的宏
2）文件实现二级页表的映射机制。实现下面函数：
alloc()
boot_pgdir_walk()
boot_map_segment()
i386_vm_init()
实验成功与否由check_boot_pgdir()函数来检验。
alloc（）函数是在物理内存中申请一段空间，并返回其在内核空间中的地址（虚拟地址）。boot_pgdir_walk()函数的功能是返回一虚拟地址对应在页表中的页表项。
boot_map_segment()函数的功能是设定虚拟地址到物理地址的对应关系

1).What entries in the page directory have been filled in at this point? 
What addresses do they map and where do they point?
        在代码中添加检测代码可以查看pgdir[0]-pgdir[1023]的相关信息
通过实验数据如下：
pgdir[0]-->0x0
pgdir[954]-->0x0
pgdir[955]--> 0x184000
pgdir[956]--> 0x166000
pgdir[957]--> 0x10c000
pgdir[958]--> 0x10d000
pgdir[959]--> 0x10c000
pgdir[960]--> 0x10e000
……
pgdir[1023]--> 0x14d000
它们每一个代表4M内存。

2).In i386_vm_init(), after check_boot_page_directory, we map the first entry of the page directory to the page table of the first 4 MB of RAM, but delete this mapping at the end of the function. Why is this necessary? What would happen if it were omitted? Does this actually limit our kernel to be 4MB? What must be true if our kernel were larger than 4MB?
      通过语句pgdir[0] = pgdir[PDX(KERNBASE)]将 first 4 MB of RAM映射到the first entry of the page directory（因为在前面已经将物理地址[0,2^32-1-KERNBASE]映射到虚拟地址[KERNBASE,2^32-1])。这样做的目的是在打开页式寻址模式（lcr0）后，重新装载段寄存器前还能继续正确寻址。delete this mappping   用语句pgdir[0]=0;  是为了在重新装载寄存器后能争取寻址。 这是因为： 在打开页式寻址模式（lcr0）后， 重新装载段寄存器前，代码段和数据段的基址是-KERNBASE(在kern/locore.S中)，此时一地址(比如eip寄存器里的值）经过段式寻址后，其值变成实际的物理地址（实际上在此之前都是这样的），以此为线性地址再经过页式寻址，找到其在页目录中的entity（此时为pgdir[0]），然后找到其页表，再找到页面。由上述过程可知这样后得到的仍为正确的物理地址（因为在前面已经将虚拟地址[KERNBASE,2^32-1]映射到物理地址 [0,2^32-1-KERNBASE]）。
再删除是因为重新装载段寄存器后，代码段等段的基址为0,一地址经过段式寻址后得到得是线性地址（值为内核空间地址的值），经线性寻址后成为物理地址）。
如果不正样做，程序在执行完语句lcr0(cr0)将不能正常执行 ,因为CPU已经不能正确的寻址,不能将eip指向的内存中的指令取出。如果不重新设置pgdir[0]不会造成寻址错误，但会造成映射错误──不在内存中的地址被认为在内存中。
这样做不会将内核限制在4M范围内，因为在重新装载段寄存器后，将能正确的寻址，不会再经过pgdir[0]，因而不会将内核限制在4M。当然重新装载段寄存器的代码必须在4M范围内。

3).On the x86, we place the kernel and user process in the same address space. What specific mechanism (i.e., what register, memory address, or bit thereof) is used to protect the kernel's memory against a malicious user process?
    内核与用户程序在同一个地址空间中，系统通过特权级实现内核与应用程序之间的保护。在段式内存管理下主要有：DPL（Discriptor Privilege Leval）段描述符所代表的内存段的特权级，RPL（Requested Privilege Level）段选择子的特权级，CPL（Current Privilege Level）当前所执行的代码的特权级（内核态/用户态）。RPL、DPL用于段访问时的特权级检查，若RPL<=DPL才允许访问。当一任务试图访问一个内存段时，只有CPL<=DPL才允许访问。通过对 kerb/pmap.c的考察，不难发现其中对内核段的描述符（DPL）与用户段描述符（DPL）的区别。
    页式内存管理模式下，内存的保护主要有页表项的R/W位U/S位及控制寄存器CR0的MP位。

    

### Physical page management
这一部分的主要任务是理解完成用于管理物理内存的内存数据结构的布局和物理内存的删除、分配等操作。具体说来是
1)阅读inc/pmap.h，理解表示物理内存页的数据结构
2)阅读inc/queue.h, 理解链表的实现和使用
3)完成与页面有关的函数，包括page_init()、page_alloc()、page_free()、pgdir_walk()、page_insert()、page_remove()等。
page_init()初始化代表每一内存页的数据结构（Page数组pages），将空闲的页的Page插入空闲页链表
page_alloc()返回一空闲页的Page
page_free()将某页的Page插入空闲页链表
page_walk()得到一线性地址的pte
page_insert()将某页面对应到一线性地址中
page_remove()去掉线性地址对应的页面

What is the maximum amount of physical memory that this operating system can support? Why?
   目前该操作系统支持的最大内存数为2^32-KERNBASE字节。因为在函数i386_vm_init()中，将线性空间[KERNBASE,2^32-1]映射到物理地址[0,2^32-KERNBASE-1]
How much space overhead is there for managing memory, if we actually had the maximum amount of 
    在该实验中，如果真的拥有256M内存，将有65×4K（内核的页目录和页表）+64K×sizeof（Page）的空间用来管理物理内存。
    当内存超过256M时，超过的部分在pages数组中仍有体现，它们还会在page_free_list中，还有可能被申请到，但是它们不能被寻址。


### Printf Potpourri

这一部分的主要任务是理解内核应如何处理IO，完成并理解printf函数的实现；进一步理解gcc调用规范和变参数函数的实现。
1. Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?
在printf.c中用到了console.c中定义的函数cons_putc()；该函数的功能是向屏幕缓冲区中写入一字符.并将屏幕缓冲区打印到控制台上.
2. Explain the following from console.c:
1if (crt_pos >= CRT_SIZE) {
2	 int i;
3	 bcopy (crt_buf + CRT_COLS, crt_buf, CRT_SIZE << 1); // 因为crt_buf为short型，占2个字节
4	 for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
5		 crt_buf[i] = 0x0700 | '  ';
6 	crt_pos -= CRT_COLS;
7 }
这段代码是在需要时滚屏(一行)。

3.Trace the execution of the following code step-by-step:
int x = 1, y = 3, z = 4;
warn("x %d, y %x, z %d\n", x, y, z);
1) in the call to kprintf(), to what does fmt point? to what does ap point?
fmt指向字符串"x %d, y %x, z %d\n"(其值为该字符串的地址)，ap指向x的值在栈中的地址
2) Second, list (in-order of execution) each call to cons_putc, va_arg, and ksprintn. 
For cons_putc, list its argument as well. 
For va_arg, list what ap points to before and after the call. 
For ksprintn list the values of it's first two arguments.
通过跟踪观察：得到下面的结果：
	va_arg: ap之前为x的值在栈中的地址,之后为y的值在栈中的地址
	ksprintn: 1 10
	cons_putc '1'
	va_arg: ap之前为y的值在栈中的地址,之后为z的值在栈中的地址
	ksprintn: 3 16
	cons_putc '3'
	va_arg: ap之前为z的值在栈中的地址,之后为z的值在栈中的地址+4
	ksprintn:4 10
	cons_putc '4'

4. Run the following code.
u_int i = 0x00646c72;
warn("H%x Wo%s", 57616, &i);
1)What is the output? Explain how this output is arrived out。.
输出为He110 World
    因为57616=0xe110，0x72=r 0x6c=l ,0x64=d。又由于Intel X86体系结构是little-endian的，所以，i变量在内存中的存储（从低到高）是0x72 0x6c 0x64 0x00。warn函数从控制字符串中得到控制信息%x，将57616从栈中取出，以16进制方式输出e110,得到控制信息%s,从栈中取出i的地址（该值作为参数传递给warn），以输出字符串的方式（一次一字节、直至遇到0x00）输出成rld。这样就造成了输出为He110 World

2)If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?
如果x86是big-endian并且其栈还是向下生长的，i的值应该设成0x726c6400.不应该改变57616

5. In the following code, what is going to be printed after 'y='? Why does this happen?
warn("x=%d y=%d", 3);
 y=后面显示的是栈中的、在参数3的上方（高地址）的4字节的值（改值每次运行是确定的，但是没有意义，所以这里没有给出）。因为根据gcc调用规范，传递参数、将参数压入栈中是调用者的责任；被调用的warn函数，根据其控制字符串到栈中取参数，它不管参数是否传递正确。所以它会将参数3后的数值取出，而该数不是调用者传递的参数。
    为了说明这点，可以在warn语句之前加入内联汇编,压入一个参数（比如1），这时y=后将显示该参数。至于怎么压参数，可能就需要深入理解gcc调用规范和gcc中对参数传递的处理通过实验，我认为不是简单的pushl，而是通过这样的代码:
asm volatile(“movl $1,%eax\n\tmovl %eax %ss:0x8(%esp));
一种解释是：在gcc中子程序参数的传递不是通过push，而是直接利用寄存器%esp的值，对内存进行赋值，偏移的数量即是有参数的位置决定。

6. Let's say that GCC changed its calling convention so that it passed arguments in declaration order (i.e., the opposite of reverse order). How would you have to change printf or its interface so that it would still be possible to pass it a variable number of arguments?
    如果gcc改变了其调用规范，参数传递是自左向右入栈，那么为实现可变参数的函数，一个比较简单的想法是改变inc/stdarg.h中的va_start、va_arg宏，可将其改成
 #define va_start(ap, last) \
      ((ap) = (va_list)&(last) - __va_size(last))
#define va_arg(ap, type) \
      (*(type *)((ap) -= __va_size(type), (ap) + __va_size(type)))
这样取参数时就会向栈顶方向取。



### Trouble Shooting

##### inline asm 
`kern/pmap.c:258: error: memory input 0 is not directly addressable`

gcc -v后显示版本号为4.0.3，但如果将gcc符号连接至gcc-3.3后便没有问题。所以，我猜测是gcc的新版本改变了语法（不允许对内存进行立即数赋值？？）。再看出错语句asm volatile (“lldt %0”::”m”(0)),其功能即是将值0放到ldt中。改成这样的也能达到相同的功能asm volatile (“lldt %%ax”::”a”(0)).编译通过。

##### section '.debug_aranges'

`can not represent section '.debug_aranges' in a.out object file format`

kernel.lds
```
  /DISCARD/ : {
        *(.comment)
        *(.debug_*)
        }
```